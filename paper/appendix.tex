
\section{Semantically different refactorings}\label{sec:semantically-different-refactorings}


%% \begin{figure}
%% \begin{lstlisting}[mathescape=true,showstringspaces=false]
%% void main(String[] args) {
%%   // Deprecated:
%%   Date date = new Date(120, 12, 30);
 
%%   // Should have been:
%%   final Calendar calendar = Calendar.getInstance();
%%   calendar.set(2020, 12, 30);
%%   final Date date = calendar.getTime();

%%   // Or:
%%   final Date date = new GregorianCalendar(2020, 12, 30)
%%                       .getTime();
%% }
%% \end{lstlisting}
%% \caption{Deprecated method example.}
%% \label{ex:deprecated-method}
%% \end{figure}


Sometimes, the deprecated and the refactored features are not semantically
equivalent on the entire domain. Reasons for this might be that a bug
was fixed, a certain functionality was improved, or simply the fact
that the deprecated feature is only expected to be used on restricted
parts of the input domain. In such a case, the deprecated and the new
feature may not be semantically equivalent on the entire input domain.

For illustration, let's consider the example in Figure~\ref{ex:three-dates}.
In the example, we make use of the constructor \texttt{new Date(year, month, day)}, 
which is deprecated with the 
recommendation to use the \texttt{Calendar} class instead.
The refactoring is not trivial given that the 
\texttt{Date} constructor expects its year parameter to be an offset
from 1900.  This needs to be
transformed by adding 1900 when using \texttt{Calendar} API, as shown in the
example. Moreover, as already seen in the motivational example in  Figure~\ref{ex:deprecated-method-other},
the \texttt{Calendar} constructor is protected,
meaning that we must use \texttt{getInstance} to obtain a
\texttt{Calendar} object.
Alternatively, the \texttt{GregorianCalendar} class may be used with
similar difficulties.
In the example, we use \texttt{date1}, \texttt{date2} and \texttt{date3} to denote the three distinct ways of constructing a date.

%% For illustration, let's consider the three distinct ways of
%% constructing a date captured in Figure~\ref{ex:three-dates} and
%% denoted by \var{date1}, \var{date2} and \var{date3}.

\begin{figure}
  \begin{lstlisting}[mathescape=true,showstringspaces=false]
  // Deprecated:
  Date date1 = new Date(year, month, day);

  // Should have been:
  Calendar calendar = Calendar.getInstance();
  calendar.set(1900 + year, month, day, 0, 0, 0);
  calendar.set(Calendar.MILLISECOND, 0);
  Date date2 = calendar.getTime();
    
  // Or:
  Date date3=new GregorianCalendar(1900+year,month,day).
             getTime();
  \end{lstlisting}
\caption{Deprecated `Date' example.}
\label{ex:three-dates}
\end{figure}

%% In the example, \var{date1} uses the deprecated
%% \var{Date(year, month, day)} constructor, whereas \var{date2} and
%% \var{date3} make use of the recommended \var{Calendar} and
%% \var{GregorianCalendar} classes.
Notably, the ways in which \texttt{date2} and \texttt{date3} are computed
represent valid refactorings for the original code computing
\texttt{date1}. However, when we provide this example to our
verification phase (as described in Section~\ref{sec:encoding}), we obtain the following
counterexample:

  \begin{lstlisting}[mathescape=true,showstringspaces=false]
    int year = -89412298;
    int month = 1439435067;
    int day = 378993182;
  \end{lstlisting}

  For these values of \texttt{year}, \texttt{month} and \texttt{day}, the three
  dates evaluate to:

  \begin{lstlisting}[mathescape=true,showstringspaces=false]
    date1: "Sat May 02 00:00:00 CEST 31580172"
    date2: "Fri Jul 02 00:00:00 CEST 31580799"
    date3: "Fri Jul 02 00:00:00 CEST 31580799"
  \end{lstlisting}

  Where \texttt{date1} evaluates to a different date than \texttt{date2} and \texttt{date3}. In principle, this should not affect any use case as the counterexample
  \texttt{year}, \texttt{month} and \texttt{day} are clearly artificial and outside the expected domain of a calendaristic date.
  In particular, for this example, we deduced that the negative year is the cause for the different values of \texttt{date1}, \texttt{date2} and \texttt{date3}.

  This counterexample is enough to stop our synthesiser from finding any of the correct refactorings in Figure~\ref{ex:three-dates}.
  To overcome this problem, we plan on computing preconditions for the verification phase. Namely, for this example, we would collect all the concrete values that
  \texttt{year}, \texttt{month} and \texttt{day} get instantiated to in the unit tests associated with the given project, and use them to
  infer a precondition over the domain of these three variables. For \texttt{year}, this should tell us that the expected year must be positive.
  Consequently, the verifier won't attempt to find counterexamples involving negative years, thus eliminating the counterexample above.



\subsection{Equivalence reduction}
JQF never generates the same exact program twice. However it may generate many
syntactically different, but semantically equivalent ones.
Program synthesis techniques make use of equivalence reduction in order to
reduce the number of equivalent programs that get explored.
For example, \cite{DBLP:conf/cav/AlbarghouthiGK13} 
prune the search space using observational equivalence with respect to a set of input/output examples, i.e., two programs are considered to be in the same equivalence class if, for all given inputs in the set of input/output examples, they produce the same outputs. Alternatively, \cite{DBLP:conf/vmcai/SmithA19} generate only programs in a specific normal form, where term rewriting is used to transform a program into its normal form. In~\cite{DBLP:journals/corr/KoukoutosKK16}, Koukoutos et al. make use of attribute grammars to only produce certain types of expressions in their normal form, thus skipping other expressions
that are syntactically different, yet semantically equivalent.
We plan on investigating some of these directions as part of future work.


%% \begin{figure}
%% \begin{lstlisting}[mathescape=true,showstringspaces=false]
%% /**
%% * Checks whether or not this {@code Rectangle}
%% * contains the point at the specified location
%% * {@code (X,Y)}.
%% *
%% * @param  X the specified X coordinate
%% * @param  Y the specified Y coordinate
%% * @return    {@code true} if the point
%% *            {@code (X,Y)} is inside this
%% *            {@code Rectangle};
%% *            {@code false} otherwise.
%% * @deprecated As of JDK version 1.1,
%% * replaced by {@code contains(int, int)}.
%% */
%% @Deprecated
%% public boolean inside(int X, int Y) {
%%   // ...
%% }
%% \end{lstlisting}
%% \caption{Javadoc hint example.}
%% \label{ex:javadoc-hint}
%% \end{figure}
