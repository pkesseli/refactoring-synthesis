
\section{Semantically different refactorings}\label{sec:semantically-different-refactorings}


%% \begin{figure}
%% \begin{lstlisting}[mathescape=true,showstringspaces=false]
%% void main(String[] args) {
%%   // Deprecated:
%%   Date date = new Date(120, 12, 30);
 
%%   // Should have been:
%%   final Calendar calendar = Calendar.getInstance();
%%   calendar.set(2020, 12, 30);
%%   final Date date = calendar.getTime();

%%   // Or:
%%   final Date date = new GregorianCalendar(2020, 12, 30)
%%                       .getTime();
%% }
%% \end{lstlisting}
%% \caption{Deprecated method example.}
%% \label{ex:deprecated-method}
%% \end{figure}


Sometimes, the deprecated and the refactored features are not semantically
equivalent on the entire domain. Reasons for this might be that a bug
was fixed, a certain functionality was improved, or simply the fact
that the deprecated feature is only expected to be used on restricted
parts of the input domain. In such a case, the deprecated and the new
feature may not be semantically equivalent on the entire input domain.

For illustration, let's consider the example in Figure~\ref{ex:three-dates}.
In the example, we make use of the constructor \texttt{new Date(year, month, day)}, 
which is deprecated with the 
recommendation to use the \texttt{Calendar} class instead.
The refactoring is not trivial given that the 
\texttt{Date} constructor expects its year parameter to be an offset
from 1900.  This needs to be
transformed by adding 1900 when using \texttt{Calendar} API, as shown in the
example. Moreover, as already seen in the motivational example in  Figure~\ref{ex:deprecated-method-other},
the \texttt{Calendar} constructor is protected,
meaning that we must use \texttt{getInstance} to obtain a
\texttt{Calendar} object.
Alternatively, the \texttt{GregorianCalendar} class may be used with
similar difficulties.
In the example, we use \texttt{date1}, \texttt{date2} and \texttt{date3} to denote the three distinct ways of constructing a date.

%% For illustration, let's consider the three distinct ways of
%% constructing a date captured in Figure~\ref{ex:three-dates} and
%% denoted by \var{date1}, \var{date2} and \var{date3}.

\begin{figure}
  \begin{lstlisting}[mathescape=true,showstringspaces=false]
  // Deprecated:
  Date date1 = new Date(year, month, day);

  // Should have been:
  Calendar calendar = Calendar.getInstance();
  calendar.set(1900 + year, month, day, 0, 0, 0);
  calendar.set(Calendar.MILLISECOND, 0);
  Date date2 = calendar.getTime();
    
  // Or:
  Date date3=new GregorianCalendar(1900+year,month,day).
             getTime();
  \end{lstlisting}
\caption{Deprecated `Date' example.}
\label{ex:three-dates}
\end{figure}

%% In the example, \var{date1} uses the deprecated
%% \var{Date(year, month, day)} constructor, whereas \var{date2} and
%% \var{date3} make use of the recommended \var{Calendar} and
%% \var{GregorianCalendar} classes.
Notably, the ways in which \texttt{date2} and \texttt{date3} are computed
represent valid refactorings for the original code computing
\texttt{date1}. However, when we provide this example to our
verification phase (as described in Section~\ref{sec:encoding}), we obtain the following
counterexample:

  \begin{lstlisting}[mathescape=true,showstringspaces=false]
    int year = -89412298;
    int month = 1439435067;
    int day = 378993182;
  \end{lstlisting}

  For these values of \texttt{year}, \texttt{month} and \texttt{day}, the three
  dates evaluate to:

  \begin{lstlisting}[mathescape=true,showstringspaces=false]
    date1: "Sat May 02 00:00:00 CEST 31580172"
    date2: "Fri Jul 02 00:00:00 CEST 31580799"
    date3: "Fri Jul 02 00:00:00 CEST 31580799"
  \end{lstlisting}

  Where \texttt{date1} evaluates to a different date than \texttt{date2} and \texttt{date3}. In principle, this should not affect any use case as the counterexample
  \texttt{year}, \texttt{month} and \texttt{day} are clearly artificial and outside the expected domain of a calendaristic date.
  In particular, for this example, we deduced that the negative year is the cause for the different values of \texttt{date1}, \texttt{date2} and \texttt{date3}.

  This counterexample is enough to stop our synthesiser from finding any of the correct refactorings in Figure~\ref{ex:three-dates}.
  To overcome this problem, we plan on computing preconditions for the verification phase. Namely, for this example, we would collect all the concrete values that
  \texttt{year}, \texttt{month} and \texttt{day} get instantiated to in the unit tests associated with the given project, and use them to
  infer a precondition over the domain of these three variables. For \texttt{year}, this should tell us that the expected year must be positive.
  Consequently, the verifier won't attempt to find counterexamples involving negative years, thus eliminating the counterexample above.


\subsection{Abstract classes and interfaces}

The counterexamples generated by the verification phase may refer to
abstract classes and interfaces. These are by default instantiated
using the mocking framework Mockito.

Alternatively, we also curate a
list of explicit constructors
of subclasses to be used in favour of Mockito mocks for certain types, and users
have the option to extend this list with a custom configuration. This is
particularly useful when the default behaviour of mocked objects under-approximate
the behaviour of the explicit constructors of subclasses.
%\todo{think if it's over or under-approximation.}
In such situations, the use of mocked objects can lead to
spurious refactorings.

This problem generally appears whenever methods are overriden in subclasses.
A trivial example of this limitation is the refactoring of the
method \texttt{layout} in the abstract class \texttt{java.awt.Component}. The
method is not abstract, but has an empty body and is meant to be overriden by
subclasses. Using this empty body as a specification will only guarantee a sound
refactoring for subclasses that do not override it. Our approach is still
guaranteed to find the preferred refactoring of using \texttt{doLayout} instead,
since we take the Javadoc hint into account. However, a more complete approach
in general would be to fuzz against all available subclasses of
\texttt{Component} on the classpath.

We explicitly avoid constructors that are not amenable to fuzzing, such as
collection constructors that take an integer capacity argument, where an
unlucky fuzzed input might lead to an out of memory error.


\subsection{Parsing the @code hints} \label{sec:parse}

As explained in Section~\ref{sec:components-seeding}, when seeding the component library, our algorithm must
interpret Javadoc hints. % provided by the developer.
In particular, \texttt{@code} blocks inside \texttt{@deprecated} sections are interpreted as code
hints, and we attempt to parse them as Java expressions. Since code hints are
not always expressed as well-formed Java, we customised the
GitHub Java parser
%%framework
to accept undeclared identifiers and type names
as arguments. For instance, the Javadoc hint for deprecating \code{boolean inside(int X, int Y)}
suggests using 
%in Figure~\ref{ex:javadoc-hint} suggests using
\texttt{contains(int, int)}, which would normally cause a parsing error as the \texttt{int} type
appears in the place of argument names. In our setting, we accept this hint as valid.
There are still situations where our parser is too strict and fails to accept
some of the code hints. Additionally, there are scenarios where, while the Javadoc
does contain a useful code hint, it is not tagged accordingly with
the \texttt{@code} tag. These situations are reflected in the experimental results
in Section~\ref{sec:experimental-results}
as some of the benchmarks for which we failed to identify a code hint. These benchmarks
are contained in Table~\ref{tab:configuration-results}, but omitted in Table~\ref{tab:configuration-results-ch} (some of the missing benchmarks from Table~\ref{tab:configuration-results-ch} do genuinely miss a code hint). We will improve our technique for collecting code hints as future work.


\subsection{Equivalence reduction}
JQF never generates the same exact program twice. However it may generate many
syntactically different, but semantically equivalent ones.
Program synthesis techniques make use of equivalence reduction in order to
reduce the number of equivalent programs that get explored.
For example, \cite{DBLP:conf/cav/AlbarghouthiGK13} 
prune the search space using observational equivalence with respect to a set of input/output examples, i.e., two programs are considered to be in the same equivalence class if, for all given inputs in the set of input/output examples, they produce the same outputs. Alternatively, \cite{DBLP:conf/vmcai/SmithA19} generate only programs in a specific normal form, where term rewriting is used to transform a program into its normal form. In~\cite{DBLP:journals/corr/KoukoutosKK16}, Koukoutos et al. make use of attribute grammars to only produce certain types of expressions in their normal form, thus skipping other expressions
that are syntactically different, yet semantically equivalent.
We plan on investigating some of these directions as part of future work.


%% \begin{figure}
%% \begin{lstlisting}[mathescape=true,showstringspaces=false]
%% /**
%% * Checks whether or not this {@code Rectangle}
%% * contains the point at the specified location
%% * {@code (X,Y)}.
%% *
%% * @param  X the specified X coordinate
%% * @param  Y the specified Y coordinate
%% * @return    {@code true} if the point
%% *            {@code (X,Y)} is inside this
%% *            {@code Rectangle};
%% *            {@code false} otherwise.
%% * @deprecated As of JDK version 1.1,
%% * replaced by {@code contains(int, int)}.
%% */
%% @Deprecated
%% public boolean inside(int X, int Y) {
%%   // ...
%% }
%% \end{lstlisting}
%% \caption{Javadoc hint example.}
%% \label{ex:javadoc-hint}
%% \end{figure}
