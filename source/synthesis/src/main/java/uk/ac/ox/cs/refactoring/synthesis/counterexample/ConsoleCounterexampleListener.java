package uk.ac.ox.cs.refactoring.synthesis.counterexample;

import uk.ac.ox.cs.refactoring.synthesis.invocation.ExecutionResult;

/** Implements {@link CounterexampleListener} by writing to the console. */
public class ConsoleCounterexampleListener implements CounterexampleListener {

  /** {@link System#lineSeparator()} */
  private static final String CRLF = System.lineSeparator();

  /** Block indent sequence. */
  private static final String INDENT = "  ";

  @Override
  public void spurious(final Counterexample counterexample) {
    System.out.printf("CE spurious: %s%n", toString(counterexample));
  }

  @Override
  public void genuine(final Counterexample counterexample, final ExecutionResult expected,
      final ExecutionResult actual) {
    System.out.printf("CE genuine: %s, expected %s but was %s.%n", toString(counterexample), toString(expected),
        toString(actual));
  }

  /**
   * Converts an {@link ExecutionResult} to {@link String}.
   * 
   * @param result {@link ExecutionResult} to convert.
   * @return {@link String} representation of {@code result}.
   */
  static String toString(final ExecutionResult result) {
    final StringBuilder stringBuilder = new StringBuilder("{ ");
    if (result.Instance != null) {
      stringBuilder.append("Instance = ");
      safeAppend(stringBuilder, result.Instance);
      stringBuilder.append(", ");
    }
    if (result.Error != null) {
      stringBuilder.append("Exception = ");
      safeAppend(stringBuilder, result.Error);
    } else {
      stringBuilder.append("Return = ");
      safeAppend(stringBuilder, result.Value);
    }
    stringBuilder.append(" }");
    return stringBuilder.toString();
  }

  /**
   * Converts an {@link Counterexample} to {@link String}.
   * 
   * @param result {@link ExecutionCounterexampleResult} to convert.
   * @return {@link String} representation of {@code result}.
   */
  static String toString(final Counterexample counterexample) {
    final StringBuilder stringBuilder = new StringBuilder("Counterexample { ");
    final boolean hasArguments = !counterexample.Arguments.isEmpty();
    final boolean hasFields = !counterexample.Fields.isEmpty();

    if (hasArguments || hasFields) {
      stringBuilder.append(CRLF);
      stringBuilder.append(INDENT);
    }
    stringBuilder.append("Instance = ");
    safeAppend(stringBuilder, counterexample.Instance);

    if (hasArguments) {
      stringBuilder.append(CRLF);
      stringBuilder.append(INDENT);
      stringBuilder.append("Arguments = ");
      safeAppend(stringBuilder, counterexample.Arguments);
    }
    if (hasFields) {
      stringBuilder.append(CRLF);
      stringBuilder.append(INDENT);
      stringBuilder.append("Fields = ");
      safeAppend(stringBuilder, counterexample.Fields);
    }

    if (hasArguments || hasFields)
      stringBuilder.append(CRLF);
    else
      stringBuilder.append(' ');

    stringBuilder.append('}');
    return stringBuilder.toString();
  }

  /**
   * Some objects generated by JQF violate internal invariants, and thus
   * {@link Object#toString()} may throw an exception. If so, we print a
   * placeholder to the log output.
   * 
   * @param stringBuilder Log output.
   * @param object        Object to log.
   */
  private static void safeAppend(final StringBuilder stringBuilder, final Object object) {
    try {
      stringBuilder.append(object);
    } catch (final Throwable e) {
      stringBuilder.append("(Object of type ");
      stringBuilder.append(object.getClass().getName());
      stringBuilder.append(')');
    }
  }
}
