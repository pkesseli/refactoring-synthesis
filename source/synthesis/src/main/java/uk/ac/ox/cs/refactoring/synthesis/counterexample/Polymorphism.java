package uk.ac.ox.cs.refactoring.synthesis.counterexample;

import java.lang.reflect.Modifier;
import java.util.Arrays;

/**
 * Helper operations for handling types which cannot be instantiated directly.
 */
public final class Polymorphism {

  /** Marks class generated by byte buddy. */
  private static final String BYTE_BUDDY_ACCESSOR = "ByteBuddyAccessor";

  /** Package into which Mockito puts generated classes. */
  private static final String MOCKITO_CODEGEN = "org.mockito.codegen";

  /** Substring contained in lambda class names. */
  private static final String LAMBDA_MARKER = "$$Lambda";

  /** Substring contained in generated proxy classes. */
  private static final String PROXY_MARKER = "$Proxy";

  private static final String SUREFIRE_MARKER = "org.apache.maven.surefire";

  private static final String JQF_MARKER = "edu.berkeley.cs.jqf";

  private static final String INTERNAL_ICU_TEXT_MARKER = "jdk.internal.icu.text";

  /**
   * Decides whether the given type can be instantiated directly.
   * 
   * @param type {@link Class} to check.
   * @return {@code true} if {@code type} is not an interface or abstract class.
   */
  public static boolean canBeInstantiated(final Class<?> type) {
    return !type.isInterface() && !Modifier.isAbstract(type.getModifiers());
  }

  /**
   * Retrieves any interface which {@code cls} implements which is not generated
   * by Mockito.
   * 
   * @param cls {@link Class} to check.
   * @return Interface {@link Class} if available, {@code null} otherwise.
   */
  public static Class<?> getNonMockitoInterface(final Class<?> cls) {
    return Arrays.stream(cls.getInterfaces())
        .filter(i -> !"org.mockito.internal.creation.bytebuddy.MockAccess".equals(i.getName())).findAny().orElse(null);
  }

  /**
   * Identifies the class modelled by a Mockito mock or dynamic proxy. Usually
   * just returns {@code originalClass},
   * but for Mockito objects a parent class or interface is chosen instead. For
   * byte buddy proxies this may return {@link Object}, indicating that class
   * names are not comparable and should be ignored in heap comparison.
   * 
   * @param cls {@link Class} of an object to clone.
   * @return {@link Class} to use as a basis for the clone.
   */
  public static Class<?> getModelledClass(final Class<?> cls) {
    if (!isMockitoCodegen(cls) && !isDynamic(cls))
      return cls;

    final Class<?> ifc = getNonMockitoInterface(cls);
    if (ifc != null)
      return ifc;

    return cls.getSuperclass();
  }

  /**
   * Indicates whether the given class was generated by Mockito.
   * 
   * @param cls {@link Class} to check.
   * @return {@code true} if synthetic Mockit class, {@code false} otherwise.
   */
  public static boolean isMockitoCodegen(final Class<?> cls) {
    final Package pkg = cls.getPackage();
    return pkg != null && MOCKITO_CODEGEN.equals(pkg.getName());
  }

  /**
   * Indicates that the given class is dynamically generated (e.g. dynamic
   * proxies, lambdas or byte buddy). This information is important since a
   * concept of "same class" cannot be enforced for such classes in heap
   * comparison. Furthermore, we do not attempt to clone the fields of dynamic
   * classes. Classes generated by Mockito are handled separately in
   * {@link #isMockitoCodegen(Class)}. While Mockito class names are also not
   * comparable, we model the comparison and cloning of Mockito objects
   * explicitly.
   * 
   * @param cls {@link Class} to check.
   * @return {@code true} if dynamic proxy, {@code false} otherwise.
   */
  public static boolean isDynamic(final Class<?> cls) {
    final String name = cls.getName();
    return name.contains(PROXY_MARKER) || name.contains(LAMBDA_MARKER) || name.contains(BYTE_BUDDY_ACCESSOR)
        || name.contains(SUREFIRE_MARKER) || name.contains(JQF_MARKER) || name.contains(INTERNAL_ICU_TEXT_MARKER);
  }
}
